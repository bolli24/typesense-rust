/*
 * Typesense API
 *
 * An open source search engine for building delightful search experiences.
 *
 * The version of the OpenAPI document: 28.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`delete_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDocumentError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDocumentsError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_search_override`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSearchOverrideError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportDocumentsError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDocumentError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_search_override`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSearchOverrideError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_search_overrides`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSearchOverridesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`import_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImportDocumentsError {
    Status400(models::ApiResponse),
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`index_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexDocumentError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`multi_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MultiSearchError {
    Status400(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchCollectionError {
    Status400(models::ApiResponse),
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDocumentError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDocumentsError {
    Status400(models::ApiResponse),
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upsert_search_override`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpsertSearchOverrideError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}


/// Delete an individual document from a collection by using its ID.
pub async fn delete_document(configuration: &configuration::Configuration, collection_name: &str, document_id: &str) -> Result<serde_json::Value, Error<DeleteDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_name = collection_name;
    let p_document_id = document_id;

    let uri_str = format!("{}/collections/{collectionName}/documents/{documentId}", configuration.base_path, collectionName=crate::apis::urlencode(p_collection_name), documentId=crate::apis::urlencode(p_document_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a bunch of documents that match a specific filter condition. Use the `batch_size` parameter to control the number of documents that should deleted at a time. A larger value will speed up deletions, but will impact performance of other operations running on the server.
pub async fn delete_documents(configuration: &configuration::Configuration, collection_name: &str, delete_documents_parameters: Option<models::DeleteDocumentsDeleteDocumentsParametersParameter>) -> Result<models::DeleteDocuments200Response, Error<DeleteDocumentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_name = collection_name;
    let p_delete_documents_parameters = delete_documents_parameters;

    let uri_str = format!("{}/collections/{collectionName}/documents", configuration.base_path, collectionName=crate::apis::urlencode(p_collection_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_delete_documents_parameters {
        req_builder = req_builder.query(&[("deleteDocumentsParameters", &param_value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteDocuments200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteDocuments200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteDocumentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_search_override(configuration: &configuration::Configuration, collection_name: &str, override_id: &str) -> Result<models::SearchOverrideDeleteResponse, Error<DeleteSearchOverrideError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_name = collection_name;
    let p_override_id = override_id;

    let uri_str = format!("{}/collections/{collectionName}/overrides/{overrideId}", configuration.base_path, collectionName=crate::apis::urlencode(p_collection_name), overrideId=crate::apis::urlencode(p_override_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchOverrideDeleteResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchOverrideDeleteResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteSearchOverrideError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Export all documents in a collection in JSON lines format.
pub async fn export_documents(configuration: &configuration::Configuration, collection_name: &str, export_documents_parameters: Option<models::ExportDocumentsExportDocumentsParametersParameter>) -> Result<String, Error<ExportDocumentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_name = collection_name;
    let p_export_documents_parameters = export_documents_parameters;

    let uri_str = format!("{}/collections/{collectionName}/documents/export", configuration.base_path, collectionName=crate::apis::urlencode(p_collection_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_export_documents_parameters {
        req_builder = req_builder.query(&[("exportDocumentsParameters", &param_value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExportDocumentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch an individual document from a collection by using its ID.
pub async fn get_document(configuration: &configuration::Configuration, collection_name: &str, document_id: &str) -> Result<serde_json::Value, Error<GetDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_name = collection_name;
    let p_document_id = document_id;

    let uri_str = format!("{}/collections/{collectionName}/documents/{documentId}", configuration.base_path, collectionName=crate::apis::urlencode(p_collection_name), documentId=crate::apis::urlencode(p_document_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the details of a search override, given its id.
pub async fn get_search_override(configuration: &configuration::Configuration, collection_name: &str, override_id: &str) -> Result<models::SearchOverride, Error<GetSearchOverrideError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_name = collection_name;
    let p_override_id = override_id;

    let uri_str = format!("{}/collections/{collectionName}/overrides/{overrideId}", configuration.base_path, collectionName=crate::apis::urlencode(p_collection_name), overrideId=crate::apis::urlencode(p_override_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchOverride`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchOverride`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSearchOverrideError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_search_overrides(configuration: &configuration::Configuration, collection_name: &str) -> Result<models::SearchOverridesResponse, Error<GetSearchOverridesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_name = collection_name;

    let uri_str = format!("{}/collections/{collectionName}/overrides", configuration.base_path, collectionName=crate::apis::urlencode(p_collection_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchOverridesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchOverridesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSearchOverridesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The documents to be imported must be formatted in a newline delimited JSON structure. You can feed the output file from a Typesense export operation directly as import.
pub async fn import_documents(configuration: &configuration::Configuration, collection_name: &str, body: &str, import_documents_parameters: Option<models::ImportDocumentsImportDocumentsParametersParameter>) -> Result<String, Error<ImportDocumentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_name = collection_name;
    let p_body = body;
    let p_import_documents_parameters = import_documents_parameters;

    let uri_str = format!("{}/collections/{collectionName}/documents/import", configuration.base_path, collectionName=crate::apis::urlencode(p_collection_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_import_documents_parameters {
        req_builder = req_builder.query(&[("importDocumentsParameters", &param_value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ImportDocumentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// A document to be indexed in a given collection must conform to the schema of the collection.
pub async fn index_document(configuration: &configuration::Configuration, collection_name: &str, body: serde_json::Value, action: Option<&str>, dirty_values: Option<models::DirtyValues>) -> Result<serde_json::Value, Error<IndexDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_name = collection_name;
    let p_body = body;
    let p_action = action;
    let p_dirty_values = dirty_values;

    let uri_str = format!("{}/collections/{collectionName}/documents", configuration.base_path, collectionName=crate::apis::urlencode(p_collection_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_action {
        req_builder = req_builder.query(&[("action", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_dirty_values {
        req_builder = req_builder.query(&[("dirty_values", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IndexDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This is especially useful to avoid round-trip network latencies incurred otherwise if each of these requests are sent in separate HTTP requests. You can also use this feature to do a federated search across multiple collections in a single HTTP request.
pub async fn multi_search<D: for<'d> serde::Deserialize<'d>>(configuration: &configuration::Configuration, multi_search_parameters: models::MultiSearchParameters, multi_search_searches_parameter: Option<models::MultiSearchSearchesParameter>) -> Result<models::MultiSearchResult<D>, Error<MultiSearchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_multi_search_parameters = multi_search_parameters;
    let p_multi_search_searches_parameter = multi_search_searches_parameter;

    let uri_str = format!("{}/multi_search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("multiSearchParameters", &p_multi_search_parameters)]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };
    req_builder = req_builder.json(&p_multi_search_searches_parameter);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MultiSearchResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MultiSearchResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MultiSearchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for documents in a collection that match the search criteria.
pub async fn search_collection<D: for<'d> serde::Deserialize<'d>>(configuration: &configuration::Configuration, collection_name: &str, search_parameters: models::SearchParameters) -> Result<models::SearchResult<D>, Error<SearchCollectionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_name = collection_name;
    let p_search_parameters = search_parameters;

    let uri_str = format!("{}/collections/{collectionName}/documents/search", configuration.base_path, collectionName=crate::apis::urlencode(p_collection_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("searchParameters", &p_search_parameters)]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchCollectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update an individual document from a collection by using its ID. The update can be partial.
pub async fn update_document(configuration: &configuration::Configuration, collection_name: &str, document_id: &str, body: serde_json::Value, dirty_values: Option<models::DirtyValues>) -> Result<serde_json::Value, Error<UpdateDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_name = collection_name;
    let p_document_id = document_id;
    let p_body = body;
    let p_dirty_values = dirty_values;

    let uri_str = format!("{}/collections/{collectionName}/documents/{documentId}", configuration.base_path, collectionName=crate::apis::urlencode(p_collection_name), documentId=crate::apis::urlencode(p_document_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_dirty_values {
        req_builder = req_builder.query(&[("dirty_values", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The filter_by query parameter is used to filter to specify a condition against which the documents are matched. The request body contains the fields that should be updated for any documents that match the filter condition. This endpoint is only available if the Typesense server is version `0.25.0.rc12` or later.
pub async fn update_documents(configuration: &configuration::Configuration, collection_name: &str, body: serde_json::Value, update_documents_parameters: Option<models::UpdateDocumentsUpdateDocumentsParametersParameter>) -> Result<models::UpdateDocuments200Response, Error<UpdateDocumentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_name = collection_name;
    let p_body = body;
    let p_update_documents_parameters = update_documents_parameters;

    let uri_str = format!("{}/collections/{collectionName}/documents", configuration.base_path, collectionName=crate::apis::urlencode(p_collection_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_update_documents_parameters {
        req_builder = req_builder.query(&[("updateDocumentsParameters", &param_value)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateDocuments200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateDocuments200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateDocumentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create or update an override to promote certain documents over others. Using overrides, you can include or exclude specific documents for a given query.
pub async fn upsert_search_override(configuration: &configuration::Configuration, collection_name: &str, override_id: &str, search_override_schema: models::SearchOverrideSchema) -> Result<models::SearchOverride, Error<UpsertSearchOverrideError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_collection_name = collection_name;
    let p_override_id = override_id;
    let p_search_override_schema = search_override_schema;

    let uri_str = format!("{}/collections/{collectionName}/overrides/{overrideId}", configuration.base_path, collectionName=crate::apis::urlencode(p_collection_name), overrideId=crate::apis::urlencode(p_override_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };
    req_builder = req_builder.json(&p_search_override_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchOverride`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchOverride`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpsertSearchOverrideError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

